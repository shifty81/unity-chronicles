using System.Collections.Concurrent;
using System.Threading;

namespace ChroniclesOfADrifter.Terrain;

/// <summary>
/// Handles asynchronous chunk generation using background worker threads.
/// Provides thread-safe chunk generation with priority based on player proximity.
/// </summary>
public class AsyncChunkGenerator : IDisposable
{
    private readonly TerrainGenerator terrainGenerator;
    private readonly ConcurrentQueue<ChunkGenerationRequest> generationQueue;
    private readonly ConcurrentDictionary<int, Chunk> generatedChunks;
    private readonly ConcurrentDictionary<int, bool> chunksInProgress;
    private readonly Thread[] workerThreads;
    private readonly CancellationTokenSource cancellationTokenSource;
    private readonly int threadCount;
    private bool isDisposed;

    /// <summary>
    /// Request for chunk generation with priority
    /// </summary>
    private class ChunkGenerationRequest
    {
        public int ChunkX { get; set; }
        public float Priority { get; set; }  // Lower values = higher priority (based on distance)
    }

    /// <summary>
    /// Creates a new async chunk generator with specified number of worker threads
    /// </summary>
    /// <param name="terrainGenerator">The terrain generator to use for chunk generation</param>
    /// <param name="threadCount">Number of worker threads (defaults to CPU core count - 1)</param>
    public AsyncChunkGenerator(TerrainGenerator terrainGenerator, int? threadCount = null)
    {
        this.terrainGenerator = terrainGenerator;
        this.threadCount = threadCount ?? Math.Max(1, Environment.ProcessorCount - 1);
        
        generationQueue = new ConcurrentQueue<ChunkGenerationRequest>();
        generatedChunks = new ConcurrentDictionary<int, Chunk>();
        chunksInProgress = new ConcurrentDictionary<int, bool>();
        cancellationTokenSource = new CancellationTokenSource();
        
        // Start worker threads
        workerThreads = new Thread[this.threadCount];
        for (int i = 0; i < this.threadCount; i++)
        {
            workerThreads[i] = new Thread(WorkerThreadLoop)
            {
                Name = $"ChunkGenerator-{i}",
                IsBackground = true,
                Priority = ThreadPriority.BelowNormal  // Lower priority to not impact main game thread
            };
            workerThreads[i].Start();
        }
    }

    /// <summary>
    /// Requests chunk generation. Returns immediately if chunk is already generated or in progress.
    /// </summary>
    /// <param name="chunkX">Chunk X coordinate</param>
    /// <param name="playerWorldX">Player's world X position (for priority calculation)</param>
    public void RequestChunkGeneration(int chunkX, float playerWorldX)
    {
        // Skip if already generated or in progress
        if (generatedChunks.ContainsKey(chunkX) || chunksInProgress.ContainsKey(chunkX))
        {
            return;
        }

        // Mark as in progress to prevent duplicate requests
        if (!chunksInProgress.TryAdd(chunkX, true))
        {
            return;  // Another thread already added it
        }

        // Calculate priority based on distance to player
        int playerChunkX = Chunk.WorldToChunkCoord((int)playerWorldX);
        float priority = Math.Abs(chunkX - playerChunkX);

        var request = new ChunkGenerationRequest
        {
            ChunkX = chunkX,
            Priority = priority
        };

        generationQueue.Enqueue(request);
    }

    /// <summary>
    /// Tries to get a generated chunk. Returns null if chunk hasn't been generated yet.
    /// </summary>
    /// <param name="chunkX">Chunk X coordinate</param>
    /// <returns>Generated chunk or null if not ready</returns>
    public Chunk? TryGetGeneratedChunk(int chunkX)
    {
        generatedChunks.TryGetValue(chunkX, out var chunk);
        return chunk;
    }

    /// <summary>
    /// Checks if a chunk has been generated
    /// </summary>
    public bool IsChunkGenerated(int chunkX)
    {
        return generatedChunks.ContainsKey(chunkX);
    }

    /// <summary>
    /// Checks if a chunk is currently being generated
    /// </summary>
    public bool IsChunkInProgress(int chunkX)
    {
        return chunksInProgress.ContainsKey(chunkX) && !generatedChunks.ContainsKey(chunkX);
    }

    /// <summary>
    /// Gets the number of chunks currently in the generation queue
    /// </summary>
    public int GetQueuedChunkCount()
    {
        return generationQueue.Count;
    }

    /// <summary>
    /// Gets the number of chunks currently being generated by worker threads
    /// </summary>
    public int GetInProgressChunkCount()
    {
        return chunksInProgress.Count - generatedChunks.Count;
    }

    /// <summary>
    /// Gets the number of completed chunks
    /// </summary>
    public int GetCompletedChunkCount()
    {
        return generatedChunks.Count;
    }

    /// <summary>
    /// Worker thread loop that processes chunk generation requests
    /// </summary>
    private void WorkerThreadLoop()
    {
        var token = cancellationTokenSource.Token;

        while (!token.IsCancellationRequested)
        {
            try
            {
                // Try to get next request (with priority sorting)
                if (TryDequeueHighestPriorityRequest(out var request) && request != null)
                {
                    // Generate the chunk
                    var chunk = new Chunk(request.ChunkX);
                    terrainGenerator.GenerateChunk(chunk);

                    // Store generated chunk
                    generatedChunks.TryAdd(request.ChunkX, chunk);
                }
                else
                {
                    // No work to do, sleep briefly
                    Thread.Sleep(10);
                }
            }
            catch (Exception ex)
            {
                // Log error but continue processing
                Console.WriteLine($"Error generating chunk: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Dequeues the highest priority request from the queue
    /// </summary>
    private bool TryDequeueHighestPriorityRequest(out ChunkGenerationRequest? request)
    {
        request = null;

        // Simple approach: dequeue up to 10 items and find the highest priority
        var tempList = new List<ChunkGenerationRequest>();
        
        for (int i = 0; i < 10 && generationQueue.TryDequeue(out var req); i++)
        {
            // Skip if already generated
            if (generatedChunks.ContainsKey(req.ChunkX))
            {
                chunksInProgress.TryRemove(req.ChunkX, out _);
                continue;
            }
            tempList.Add(req);
        }

        if (tempList.Count == 0)
        {
            return false;
        }

        // Find highest priority (lowest value)
        var highestPriorityRequest = tempList.OrderBy(r => r.Priority).First();
        request = highestPriorityRequest;
        
        // Re-queue the others
        foreach (var req in tempList)
        {
            if (req != highestPriorityRequest)
            {
                generationQueue.Enqueue(req);
            }
        }

        return true;
    }

    /// <summary>
    /// Clears all cached chunks (useful when changing world seed)
    /// </summary>
    public void ClearCache()
    {
        generatedChunks.Clear();
        chunksInProgress.Clear();
        
        // Clear the queue
        while (generationQueue.TryDequeue(out _)) { }
    }

    /// <summary>
    /// Disposes the async chunk generator and stops all worker threads
    /// </summary>
    public void Dispose()
    {
        if (isDisposed)
        {
            return;
        }

        isDisposed = true;

        // Signal threads to stop
        cancellationTokenSource.Cancel();

        // Wait for all threads to complete
        foreach (var thread in workerThreads)
        {
            if (thread.IsAlive)
            {
                thread.Join(1000);  // Wait up to 1 second per thread
            }
        }

        cancellationTokenSource.Dispose();
    }
}
